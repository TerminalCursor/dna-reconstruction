package main

import (
	"fmt"
)

func PrintMatch(scaffold, staplePart Strand, offset int) {
	fmt.Printf("%s\n", scaffold.Bases())
	for i := 0; i < offset + staplePart.Length(); i++ {
		if i >= offset {
			fmt.Printf("%c", staplePart.Bases()[i-offset])
		} else {
			fmt.Printf(" ")
		}
	}
	fmt.Printf("\n")
}

func GetPermutations(input [][]int, prep []int, WINDOW_SIZE int) [][]int {
	var out [][]int
	if(len(input) > 1) {
		if len(input[0]) > 0 {
			for i := 0; i < len(input[0]); i++ {
				validPath := true
				for j := 0; j < len(prep); j++ {
					if prep[j] <= input[0][i] && input[0][i] < (prep[j] + WINDOW_SIZE) && prep[j] != -1 {
						validPath = false
						break
					}
				}
				if validPath {
					perms := GetPermutations(input[1:], append(prep, input[0][i]), WINDOW_SIZE)
					for j := 0; j < len(perms); j++ {
						out = append(out, perms[j])
					}
				}
			}
		} else {
			perms := GetPermutations(input[1:], append(prep, -1), WINDOW_SIZE)
			for j := 0; j < len(perms); j++ {
				out = append(out, perms[j])
			}
		}
	} else {
		for i := 0; i < len(input[0]); i++ {
			validPath := true
			for j := 0; j < len(prep); j++ {
				if prep[j] <= input[0][i] && input[0][i] < (prep[j] + WINDOW_SIZE) && prep[j] != -1 {
					validPath = false
					break
				}
			}
			if validPath {
				out = append(out, append(prep, input[0][i]))
			}
		}
	}
	return out
}

/* https://en.wikipedia.org/wiki/ANSI_escape_code */

func main() {
	fmt.Printf("\033[91mDNA\033[0m \033[94mReconstruction\033[0m \033[33mv00.01\033[0m\n")
	m13mp18 := MakeStrand("TGAT AGAC GGTT TTTC GCCC TTTG ACGT TGGA GTCC ACGT TCTT TAAT AGTG GACT CTTG")
	WINDOW_SIZE := 3
	eStaple := MakeStaple(MakeStrand("ACTCTGAC"), WINDOW_SIZE)
	strandConfs := make([][]int, eStaple.Length())
	for i := 0; i < eStaple.Length(); i++ {
		matches := eStaple.pieces[i].Match(m13mp18)
		strandConfs[i] = matches
		fmt.Printf("%s %v\n", eStaple.pieces[i].Bases(), matches)
		//for j := 0; j < len(matches); j++ {
		//	PrintMatch(m13mp18, eStaple.pieces[i], matches[j])
		//}
	}
	//fmt.Printf("%v\n", strandConfs)
	possibleCombinations := GetPermutations(strandConfs, []int{}, WINDOW_SIZE)
	//fmt.Printf("%v\n", possibleCombinations)
	var mS []MatchedScaffold
	for i := 0; i < len(possibleCombinations); i++ {
		mS = append(mS, MatchedScaffold{m13mp18, eStaple, possibleCombinations[i]})
	}
	for i := 0; i < len(mS); i++ {
		fmt.Printf("%s", mS[i].MatchedString())
	}
}
